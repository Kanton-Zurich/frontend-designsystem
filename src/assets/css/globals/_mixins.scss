/**
 * Hide visually
 *
 * See http://snook.ca/archives/html_and_css/hiding-content-for-accessibility
 * for discussion of different solutions
 */
@mixin visuallyhidden() {
  border: 0;
  clip: rect(0 0 0 0);
  height: 1px;
  margin: -1px;
  overflow: hidden;
  padding: 0;
  position: absolute;
  width: 1px;
}

/**
 *
 */
@mixin visuallyhiddenReset() {
  clip: auto;
  height: auto;
  margin: 0;
  overflow: visible;
  position: static;
  width: auto;
}

/**
 *
 */
@mixin visuallyhiddenFocusable() {
  @include visuallyhidden;

  &:focus,
  &:active {
    @include visuallyhiddenReset;
  }
}

/**
 * Contain floats with clearfix
 *
 * http://nicolasgallagher.com/micro-clearfix-hack/
 */
@mixin clearfix() {
  *zoom: 1;

  &:before,
  &:after {
    content: ' ';
    display: table;
  }

  &:after {
    clear: both;
  }
}


/**
 * Lists with layout purpose
 */

@mixin resetList() {
  list-style: none;
  margin: 0;
  padding: 0;
}


/**
 * Replace text
 */

@mixin replaceText() {
  display: block;
  overflow: hidden;
  text-indent: 100%;
  white-space: nowrap;
}


/**
 * Better font rendering (on OS X)
 * http://maximilianhoffmann.com/posts/better-font-rendering-on-osx
 *
 * Usage:
 *
 * .xy--dark-on-light {
 * 	@include fontSmoothing;
 * }
 * .xy--light-on-dark {
 * 	@include fontSmoothingReset;
 * }
 */

@mixin fontSmoothing() {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/**
 *
 */
@mixin fontSmoothingReset() {
  -webkit-font-smoothing: subpixel-antialiased;
  -moz-osx-font-smoothing: auto;
}


/**
 * Placeholder in input fields
 */
@mixin placeholder() {
  &::-webkit-input-placeholder {
    @content;
  }

  &:-moz-placeholder { // Firefox 18-
    @content;
  }

  &::-moz-placeholder { // Firefox 19+
    @content;
  }

  &:-ms-input-placeholder {
    @content;
  }
}

/**
 * Generate linear interpolated size values through multiple break points
 * https://www.smashingmagazine.com/2017/05/fluid-responsive-typography-css-poly-fluid-sizing/
 *
 * @param $property - A string CSS property name
 * @param $map - A SASS map of viewport unit and size value pairs
 * @requires function linearInterpolation
 * @example
 *   @include polyFluidSizing('font-size', (small: 22px, medium: 24px, large: 34px));
 * @author Jake Wilson <jake.e.wilson@gmail.com>
 */
@mixin polyFluidSizing($property, $map) {
  // Get the number of provided breakpoints
  $length: length(map-keys($map));

  // Error if the number of breakpoints is < 2
  @if ($length < 2) {
    @error 'polyFluidSizing() $map requires at least 2 values';
  }

  $keys: map-keys($map);

  // Minimum size
  #{$property}: map-get($map, nth($keys, 1));

  // Interpolated size through breakpoints
  @for $i from 1 through ($length - 1) {
    $breakpointValue: map-get($mqBreakpoints, nth($keys, $i));
    $sizeValue: map-get($map, nth($keys, $i));
    $nextBreakpointValue: map-get($mqBreakpoints, nth($keys, $i+1));
    $nextSizeValue: map-get($map, nth($keys, ($i+1)));

    @media ( min-width: $breakpointValue ) {
      #{$property}: linearInterpolation(($breakpointValue: $sizeValue, $nextBreakpointValue: $nextSizeValue)); //stylelint-disable-line
    }
  }

  // Maxmimum size
  @media (min-width: map-get($mqBreakpoints, nth($keys, $length))) { //stylelint-disable-line
    #{$property}: map-get($map, nth($keys, $length));
  }
}

/**
 * Calculate the definition of a line between two points
 *
 * @param $map - A SASS map of viewport widths and size value pairs
 * @returns A linear equation as a calc() function
 * @example
 *   font-size: linearInterpolation((tiny: 18px, medium: 26px));
 * @author Jake Wilson <jake.e.wilson@gmail.com>
 */
@function linearInterpolation($map) {
  $keys: map-keys($map);

  @if (length($keys) != 2) {
    @error 'linear-interpolation() $map must be exactly 2 values';
  }
  // The slope
  $m: (map-get($map, nth($keys, 2)) - map-get($map, nth($keys, 1)))/(nth($keys, 2) - nth($keys, 1));

  // The y-intercept
  $b: map-get($map, nth($keys, 1)) - $m * nth($keys, 1);

  // Determine if the sign should be positive or negative
  $sign: '+';

  @if ($b < 0) {
    $sign: '-';
    $altSign: '+';
    $b: abs($b);
  }

  @return calc(#{$m*100}vw #{$sign} #{$b}); //stylelint-disable-line
}

/**
 * Get Value For Breakpoint or next smalles which is in target map available
 *
 * @param $targetMap - A Sass Map which is the target
 * @param $breakpoint - The whanted breakpoint
 * @returns A value in rem
 * @author Marcel BÃ¼hrig <marcel.buehrig@zeix.com>
 */
@function getValueForBreakpoint($targetMap, $breakpoint) {
  @if map-has-key($targetMap, $breakpoint) {
    @return map-get($targetMap, $breakpoint);
  } @else {
    $breakpointIndex: index(map-keys($mqBreakpoints), $breakpoint);

    @if $breakpointIndex {
      $breakpointIndex: $breakpointIndex - 1;

      @while $breakpointIndex >= 0 {
        $searchableBreakpoint: nth(map-keys($mqBreakpoints), $breakpointIndex);

        @if map-has-key($targetMap, $searchableBreakpoint) {
          @return map-get($targetMap, $searchableBreakpoint);
        }

        $breakpointIndex: $breakpointIndex - 1;
      }

      @error 'Something went horribly wrong, it seems your targetMap doesn\'t have real breakpoints, please consider $mqBreakpoints for the breakpoint names';
    } @else {
      @error 'The given breakpoint `#{$breakpoint}` hasn\'t been found in $mqBreakpoints';
    }
  }
}

/**
 * Generate CSS by giving a list or string and a value
 *
 * @param $listOrString - Either a list or a astring
 * @param $value - String, can be whatever value you like
 */
@mixin generateCSSFromListOrString($listOrString, $value, $isNegative: false) {
  @if (type-of($listOrString) == list) {
    @for $i from 1 through length($listOrString) {
      @if $isNegative {
        #{nth($listOrString, $i)}: -$value;
      } @else {
        #{nth($listOrString, $i)}: $value;
      }
    }
  } @else if (type-of($listOrString) == string) {
    @if $isNegative {
      #{$listOrString}: -$value;
    } @else {
      #{$listOrString}: $value;
    }
  } @else {
    @error 'The targeted variable is neither a list nor a string. BAD';
  }
}

/**
 * Gets the according values from the sizeCurves and maps it to the wanted attributes
 *
 * @param $attributes - A list or a string of attributes (if string, there is only one)
 * @param $curve - The key value of the curve, e.g. regular
 * @param $map- The Map with all the wanted size curves inside - default: $sizeCurves
 */
@mixin sizeCurve($attributes, $curve, $map: $sizeCurves, $isNegative: false) {
  @if (map-has-key($map, $curve)) {
    $selectedCurve: map-get($map, $curve);

    @each $breakpoint, $size in $selectedCurve {
      @if $breakpoint == tiny {
        @include generateCSSFromListOrString($attributes, pxToRem(map-get($selectedCurve, tiny)), $isNegative);
      } @else {
        @include mq($from: $breakpoint) {
          @include generateCSSFromListOrString($attributes, pxToRem(map-get($selectedCurve, $breakpoint)), $isNegative);
        }
      }
    }
  } @else {
    @error 'The curve `#{$curve}` doesn\'t exist in the provided $map';
  }
}

/**
 * Grid offset for content elements
 */
@mixin gridNestedOffset($attributes, $offsetColumnCount, $columnsWidthCount, $isNegative: false, $trailingGutter: true) {
  @include mq($from: tiny, $to: xsmall) {
    $columnsOffset: (100% / 6) * $offsetColumnCount;
    $gutterCorrection: (pxToRem(map-get($grid-margin-gutters, tiny)) / map-get($columnsWidthCount, tiny)) * $offsetColumnCount;
    @if ($trailingGutter == false) {
      $gutterCorrection: (pxToRem(map-get($grid-margin-gutters, tiny)) / map-get($columnsWidthCount, tiny)) * $offsetColumnCount - pxToRem(map-get($grid-margin-gutters, tiny));
    }
    @if $isNegative == true {
      @include generateCSSFromListOrString($attributes, calc(-#{$columnsOffset} - #{$gutterCorrection}));
    } @else {
      @include generateCSSFromListOrString($attributes, calc(#{$columnsOffset} + #{$gutterCorrection}));
    }
  }
  @include mq($from: xsmall, $to: small) {
    $columnsOffset: (100% / 6) * $offsetColumnCount;
    $gutterCorrection: (pxToRem(map-get($grid-margin-gutters, xsmall)) / map-get($columnsWidthCount, tiny)) * $offsetColumnCount;
    @if ($trailingGutter == false) {
      $gutterCorrection: (pxToRem(map-get($grid-margin-gutters, xsmall)) / map-get($columnsWidthCount, tiny)) * $offsetColumnCount - pxToRem(map-get($grid-margin-gutters, xsmall));
    }
    @if $isNegative == true {
      @include generateCSSFromListOrString($attributes, calc(-#{$columnsOffset} - #{$gutterCorrection}));
    } @else {
      @include generateCSSFromListOrString($attributes, calc(#{$columnsOffset} + #{$gutterCorrection}));
    }
  }
  @include mq($from: small, $to: medium) {
    $columnsOffset: (100% / 10) * $offsetColumnCount;
    $gutterCorrection: (pxToRem(map-get($grid-margin-gutters, xsmall)) / map-get($columnsWidthCount, small)) * $offsetColumnCount;
    @if ($trailingGutter == false) {
      $gutterCorrection: (pxToRem(map-get($grid-margin-gutters, xsmall)) / map-get($columnsWidthCount, small)) * $offsetColumnCount - pxToRem(map-get($grid-margin-gutters, xsmall));
    }
    @if $isNegative == true {
      @include generateCSSFromListOrString($attributes, calc(-#{$columnsOffset} - #{$gutterCorrection}));
    } @else {
      @include generateCSSFromListOrString($attributes, calc(#{$columnsOffset} + #{$gutterCorrection}));
    }
  }
  @include mq($from: medium, $to: large) {
    $columnsOffset: (100% / 9) * $offsetColumnCount;
    $gutterCorrection: (pxToRem(map-get($grid-margin-gutters, medium)) / map-get($columnsWidthCount, medium)) * $offsetColumnCount;
    @if ($trailingGutter == false) {
      $gutterCorrection: (pxToRem(map-get($grid-margin-gutters, medium)) / map-get($columnsWidthCount, medium)) * $offsetColumnCount - pxToRem(map-get($grid-margin-gutters, medium));
    }
    @if $isNegative == true {
      @include generateCSSFromListOrString($attributes, calc(-#{$columnsOffset} - #{$gutterCorrection}));
    } @else {
      @include generateCSSFromListOrString($attributes, calc(#{$columnsOffset} + #{$gutterCorrection}));
    }
  }
  @include mq($from: large, $to: xlarge) {
    $columnsOffset: (100% / 8) * $offsetColumnCount;
    $gutterCorrection: (pxToRem(map-get($grid-margin-gutters, medium)) / map-get($columnsWidthCount, medium)) * $offsetColumnCount;
    @if ($trailingGutter == false) {
      $gutterCorrection: (pxToRem(map-get($grid-margin-gutters, medium)) / map-get($columnsWidthCount, medium)) * $offsetColumnCount - pxToRem(map-get($grid-margin-gutters, medium));
    }
    @if $isNegative == true {
      @include generateCSSFromListOrString($attributes, calc(-#{$columnsOffset} - #{$gutterCorrection}));
    } @else {
      @include generateCSSFromListOrString($attributes, calc(#{$columnsOffset} + #{$gutterCorrection}));
    }
  }
  @include mq($from: xlarge) {
    $columnsOffset: (100% / 8) * $offsetColumnCount;
    $gutterCorrection: (pxToRem(map-get($grid-margin-gutters, xlarge)) / map-get($columnsWidthCount, large)) * $offsetColumnCount;
    @if ($trailingGutter == false) {
      $gutterCorrection: (pxToRem(map-get($grid-margin-gutters, xlarge)) / map-get($columnsWidthCount, large)) * $offsetColumnCount - pxToRem(map-get($grid-margin-gutters, xlarge));
    }
    @if $isNegative == true {
      @include generateCSSFromListOrString($attributes, calc(-#{$columnsOffset} - #{$gutterCorrection}));
    } @else {
      @include generateCSSFromListOrString($attributes, calc(#{$columnsOffset} + #{$gutterCorrection}));
    }
  }
}

/**
 * Grid bleeding for content elements
 */
@mixin gridBleed($trailingGutters: false, $fullwidth: false) {
  @if $trailingGutters == true {
    @include sizeCurve(padding-left padding-right, bleed, $grid-outer-gutters);

    width: calc(100vw);
    width: calc(100vw - var(--scrollbar-wd)); //stylelint-disable-line
    @if $fullwidth == false {
      max-width: $sizeGlobalMaxWidth;
    }
  } @else {
    width: calc(100vw + 2px);
    width: calc(100vw + 2px - var(--scrollbar-wd)); //stylelint-disable-line
    @if $fullwidth == false {
      max-width: $sizeGlobalMaxWidth;
    }
  }
  transform: translateX(-50%);
  margin-left: 50%;

  @include mq($from: small, $to: medium) {
    $translateLeft: -50% - (2/12/2) * 100;
    $additionalRem: pxToRem(map-get($grid-margin-gutters, tiny)) * 1.5/6;

    transform: translateX(calc(#{$translateLeft} + #{$additionalRem}));
  }
  @include mq($from: medium, $to: large) {
    $translateLeft: -50% - (1/12/2) * 100;
    $additionalRem: pxToRem(map-get($grid-margin-gutters, medium))/12 - 0.01;

    transform: translateX(calc(#{$translateLeft} + #{$additionalRem}));
  }
}

/**
 * Resets the button no styling
 */
@mixin blankButton() {
  border: none;
  background: none;
  padding: 0;
  -webkit-appearance: none; //stylelint-disable-line
  line-height: 1.5;

  text-align: left;
  cursor: pointer;

  &:focus {
    outline: none;
  }
}

/**
 * SVG Icons
 */
@function svg-tickmark($color) {
  $encodedSvg: encode_Base64('<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 24 18" style="enable-background:new 0 0 24 18" xml:space="preserve"><path d="M17.25 6.75L9.375 14.25L6 10.875L4.5 12.375L9.375 17.25L18.75 8.25L17.25 6.75Z" fill="' + rgba($color, 0.99) + '" /></svg>'); // stylelint-disable-line

  @return 'data:image/svg+xml;base64,#{$encodedSvg}';
}

/**
 * Transition Creator Mixin, default is set to create the default hover transition
 *
 */
@mixin transition($propertyList, $time: $transitionTimeSimple, $easing: $transitionEasingDefault) {
  @if (type-of($propertyList) == list) {
    $propertyString: '';

    @for $i from 1 through length($propertyList) {
      $propertyString: $propertyString + nth($propertyList, $i) + ' ' + $time + ' ' + $easing + ', ';
    }

    transition: unquote(str-slice($propertyString, 1, -3));
  } @else {
    transition: $propertyList $time $easing;
  }
}

@function multiplyMapValues($map, $factor) {
  $newMap: ();

  @each $breakpoint, $value in $map {
    $newMap: map-merge($newMap, ($breakpoint: $value * $factor));
  }

  @return $newMap;
}

@mixin resetList() {
  list-style-type: none;
  margin: 0;
  padding: 0;
}

