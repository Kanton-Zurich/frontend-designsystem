/**
 * Hide visually
 *
 * See http://snook.ca/archives/html_and_css/hiding-content-for-accessibility
 * for discussion of different solutions
 */

@mixin visuallyhidden() {
  border: 0;
  clip: rect(0 0 0 0);
  height: 1px;
  margin: -1px;
  overflow: hidden;
  padding: 0;
  position: absolute;
  width: 1px;
}
@mixin visuallyhiddenReset() {
  clip: auto;
  height: auto;
  margin: 0;
  overflow: visible;
  position: static;
  width: auto;
}
@mixin visuallyhiddenFocusable() {
  @include visuallyhidden;

  &:focus,
  &:active {
    @include visuallyhiddenReset;
  }
}


/**
 * Contain floats with clearfix
 *
 * http://nicolasgallagher.com/micro-clearfix-hack/
 */

@mixin clearfix() {
  *zoom: 1;

  &:before,
  &:after {
    content: ' ';
    display: table;
  }

  &:after {
    clear: both;
  }
}


/**
 * Lists with layout purpose
 */

@mixin resetList() {
  list-style: none;
  margin: 0;
  padding: 0;
}


/**
 * Replace text
 */

@mixin replaceText() {
  display: block;
  overflow: hidden;
  text-indent: 100%;
  white-space: nowrap;
}


/**
 * Better font rendering (on OS X)
 * http://maximilianhoffmann.com/posts/better-font-rendering-on-osx
 *
 * Usage:
 *
 * .xy--dark-on-light {
 * 	@include fontSmoothing;
 * }
 * .xy--light-on-dark {
 * 	@include fontSmoothingReset;
 * }
 */

@mixin fontSmoothing() {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
@mixin fontSmoothingReset() {
  -webkit-font-smoothing: subpixel-antialiased;
  -moz-osx-font-smoothing: auto;
}


/**
 * Placeholder in input fields
 */

@mixin placeholder() {
  &::-webkit-input-placeholder {
    @content;
  }

  &:-moz-placeholder { // Firefox 18-
    @content;
  }

  &::-moz-placeholder { // Firefox 19+
    @content;
  }

  &:-ms-input-placeholder {
    @content;
  }
}

/**
 * Generate linear interpolated size values through multiple break points
 * https://www.smashingmagazine.com/2017/05/fluid-responsive-typography-css-poly-fluid-sizing/
 *
 * @param $property - A string CSS property name
 * @param $map - A SASS map of viewport unit and size value pairs
 * @requires function linear-interpolation
 * @requires function map-sort
 * @example
 *   @include poly-fluid-sizing('font-size', (576px: 22px, 768px: 24px, 992px: 34px));
 * @author Jake Wilson <jake.e.wilson@gmail.com>
 */
@mixin poly-fluid-sizing($property, $map) {
  // Get the number of provided breakpoints
  $length: length(map-keys($map));

  // Error if the number of breakpoints is < 2
  @if ($length < 2) {
    @error 'poly-fluid-sizing() $map requires at least values';
  }

  // Sort the map by viewport width (key)
  $map: map-sort($map);
  $keys: map-keys($map);

  // Minimum size
  #{$property}: map-get($map, nth($keys, 1));

  // Interpolated size through breakpoints
  @for $i from 1 through ($length - 1) {
    @media ( min-width: nth( $keys, $i ) ) {
      #{$property}: linear-interpolation((nth($keys, $i): map-get($map, nth($keys, $i)), nth($keys, ($i+1)): map-get($map, nth($keys, ($i + 1)))));
    }
  }

  // Maxmimum size
  @media ( min-width: nth( $keys, $length ) ) {
    #{$property}: map-get($map, nth($keys, $length));
  }
}

/**
 * Calculate the definition of a line between two points
 *
 * @param $map - A SASS map of viewport widths and size value pairs
 * @returns A linear equation as a calc() function
 * @example
 *   font-size: linear-interpolation((320px: 18px, 768px: 26px));
 * @author Jake Wilson <jake.e.wilson@gmail.com>
 */
@function linear-interpolation($map) {
  $keys: map-keys($map);

  @if (length($keys) != 2) {
    @error 'linear-interpolation() $map must be exactly 2 values';
  }
  // The slope
  $m: (map-get($map, nth($keys, 2)) - map-get($map, nth($keys, 1)))/(nth($keys, 2) - nth($keys, 1));

  // The y-intercept
  $b: map-get($map, nth($keys, 1)) - $m * nth($keys, 1);

  // Determine if the sign should be positive or negative
  $sign: '+';

  @if ($b < 0) {
    $sign: '-';
    $b: abs($b);
  }

  @return calc(#{$m*100}vw #{$sign} #{$b});
}

/**
 * Sort a SASS list
 *
 * @param $list - A SASS list
 * @returns A sorted SASS list
 * @requires function list-remove
 * @author Jake Wilson <jake.e.wilson@gmail.com>
 */
@function list-sort($list) {
  $sortedlist: ();

  @while length($list) > 0 {
    $value: nth($list, 1);

    @each $item in $list {

      @if $item < $value {
        $value: $item;
      }
    }
    $sortedlist: append($sortedlist, $value, 'space');
    $list: list-remove($list, index($list, $value));
  }

  @return $sortedlist;
}

/**
 * Sort map by keys
 *
 * @param $map - A SASS map
 * @returns A SASS map sorted by keys
 * @requires function list-sort
 * @author Jake Wilson <jake.e.wilson@gmail.com>
 */
@function map-sort($map) {
  $keys: list-sort(map-keys($map));
  $sortedMap: ();

  @each $key in $keys {
    $sortedMap: map-merge($sortedMap, ($key: map-get($map, $key)));
  }

  @return $sortedMap;
}

/**
 * Remove an item from a list
 *
 * @param $list - A SASS list
 * @param $index - The list index to remove
 * @returns A SASS list
 * @author Jake Wilson <jake.e.wilson@gmail.com>
 */
@function list-remove($list, $index) {
  $newList: ();

  @for $i from 1 through length($list) {

    @if $i != $index {
      $newList: append($newList, nth($list, $i), 'space');
    }
  }

  @return $newList;
}

/**
 * Get Value For Breakpoint or next smalles which is in target map available
 *
 * @param $targetMap - A Sass Map which is the target
 * @param $breakpoint - The whanted breakpoint
 * @returns A value in rem
 * @author Marcel BÃ¼hrig <marcel.buehrig@zeix.com>
 */
@function getValueForBreakpoint($targetMap, $breakpoint) {
  @if map-has-key($targetMap, $breakpoint) {
    @return pxToRem(map-get($targetMap, $breakpoint));
  } @else {
    $breakpointIndex: index(map-keys($mqBreakpoints), $breakpoint);

    @if $breakpointIndex {
      $breakpointIndex: $breakpointIndex - 1;

      @while $breakpointIndex >= 0 {
        $searchableBreakpoint: nth(map-keys($mqBreakpoints), $breakpointIndex);

        @if map-has-key($targetMap, $searchableBreakpoint) {
          @return pxToRem(map-get($targetMap, $searchableBreakpoint));
        }

        $breakpointIndex: $breakpointIndex - 1;
      }

      @error 'Something went horribly wrong, it seems your targetMap doesn\'t have real breakpoints, please consider $mqBreakpoints for the breakpoint names';
    } @else {
      @error 'The given breakpoint `#{$breakpoint}` hasn\'t been found in $mqBreakpoints';
    }
  }
}

/**
 * Generate CSS by giving a list or string and a value
 *
 * @param $listOrString - Either a list or a astring
 * @param $value - String, can be whatever value you like
 */
@mixin generateCSSFromListOrString($listOrString, $value) {
  @if (type-of($listOrString) == list) {
    @for $i from 1 through length($listOrString) {
      #{nth($listOrString, $i)}: $value;
    }
  } @else if (type-of($listOrString) == string) {
    #{$listOrString}: $value;
  } @else {
    @error 'The targeted variable is neither a list nor a string. BAD';
  }
}

/**
 * Gets the according values from the sizeCurves and maps it to the wanted attributes
 *
 * @param $attributes - A list or a string of attributes (if string, there is only one)
 * @param $curve - The key value of the curve, e.g. regular
 * @param $curveMap - The Map with all the wanted size curves inside - default: $sizeCurves
 */
@mixin sizeCurve($attributes, $curve, $curveMap: $sizeCurves) {
  @if (map-has-key($curveMap, $curve)) {
    $selectedCurve: map-get($curveMap, $curve);

    @each $breakpoint, $size in $selectedCurve {
      @if $breakpoint == tiny {
        @include generateCSSFromListOrString($attributes, pxToRem(map-get($selectedCurve, tiny)));
      } @else {
        @include mq($from: $breakpoint) {
          @include generateCSSFromListOrString($attributes, pxToRem(map-get($selectedCurve, $breakpoint)));
        }
      }
    }
  } @else {
    @error 'The curve `#{$curve}` doesn\'t exist in the provided $curveMap';
  }
}
